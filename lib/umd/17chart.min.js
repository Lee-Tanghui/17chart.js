!(function(e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = t(require('echarts')))
    : 'function' == typeof define && define.amd
    ? define(['echarts'], t)
    : ((e =
        'undefined' != typeof globalThis ? globalThis : e || self).$17chart = t(
        e.echarts,
      ))
})(this, function(e) {
  'use strict'
  function t(e) {
    if (e && e.__esModule) return e
    var t = Object.create(null)
    return (
      e &&
        Object.keys(e).forEach(function(o) {
          if ('default' !== o) {
            var r = Object.getOwnPropertyDescriptor(e, o)
            Object.defineProperty(
              t,
              o,
              r.get
                ? r
                : {
                    enumerable: !0,
                    get: function() {
                      return e[o]
                    },
                  },
            )
          }
        }),
      (t.default = e),
      Object.freeze(t)
    )
  }
  var o,
    r = t(e)
  !(function(e) {
    ;(e.RIGHT = 'right'),
      (e.LEFT = 'left'),
      (e.TOP = 'top'),
      (e.bottom = 'bottom')
  })(o || (o = {}))
  const i = e => e.every(e => Array.isArray(e)),
    n = e => Array.isArray(e),
    a = e =>
      new RegExp('([一-鿿]|[。；，：“”（）、？《》！【】￥])+', 'g').test(e),
    s = (e, ...t) => (
      t.forEach(t => {
        t && l(e, t)
      }),
      e
    ),
    l = (e, t) => {
      if (t instanceof Array)
        return (
          (e = []),
          void t.forEach(t => {
            e.push(l({}, t))
          })
        )
      Object.keys(t).forEach(o => {
        'object' == typeof t[o]
          ? t[o] instanceof Array
            ? ((e[o] = []),
              t[o].forEach(t => {
                if ('[object Object]' === Object.prototype.toString.call(t)) {
                  let r = {}
                  l(r, t), e[o].push(r)
                } else e[o].push(t)
              }))
            : (('object' != typeof e[o] || e[o] instanceof Array) &&
                (e[o] = {}),
              l(e[o], t[o]))
          : (e[o] = t[o])
      })
    },
    c = function(e) {
      return null == e
    },
    d = function(e, t) {
      return t.split('.').reduce(function(e, t) {
        return c(e)
          ? void 0
          : (function(e, t) {
              const o = p.exec(t)
              if (o) {
                const t = o[1],
                  r = o[2]
                return c(e[t]) ? void 0 : e[t][r]
              }
              return e[t]
            })(e, t)
      }, e)
    },
    p = /([^\[]*)\[([0-9]*)\]/
  function h(e, t, o) {
    var r, i, n
    if (
      (Array.isArray(t) && (r = t.slice(0)),
      'string' == typeof t && (r = t.split('.')),
      'symbol' == typeof t && (r = [t]),
      !Array.isArray(r))
    )
      throw new Error('props arg must be an array, a string or a symbol')
    if (!(i = r.pop())) return !1
    for (f(i); (n = r.shift()); )
      if (
        (f(n),
        void 0 === e[n] && (e[n] = {}),
        !(e = e[n]) || 'object' != typeof e)
      )
        return !1
    return (e[i] = o), !0
  }
  function f(e) {
    if ('__proto__' == e || 'constructor' == e || 'prototype' == e)
      throw new Error('setting of prototype values not supported')
  }
  const y = {
      FONT_COLOR: '#666',
      AXIS_LINE_COLOR: '#eee',
      THEME_PRIMARY_COLORS: [
        '#5B8FF9',
        '#61DDAA',
        '#748AB1',
        '#F6BD16',
        '#7262FD',
        '#78D3F8',
        '#9661BC',
        '#F6903D',
        '#008685',
        '#F08BB4',
      ],
    },
    m = 'yq_chart_tooltip--bar',
    u = 12,
    g = 45,
    x = (e, t) => {
      const {
        markLine: r,
        isPercent: i,
        dataZoom: n,
        xAxis: l,
        yAxis: c,
        percentFixed: p,
      } = t
      if (r) {
        const t = (e => ({
          silent: !0,
          symbol: 'none',
          lineStyle: { color: '#666' },
          label: {
            position: 'insideEndBottom',
            color: '#666',
            formatter: t => {
              const { name: o, value: r } = t
              return o ? `${o}: ${e ? (100 * r).toFixed(0) + '%' : r}` : r
            },
          },
          data: [],
        }))(i)
        s(t, r), (e.series[0].markLine = t)
      }
      if (n) {
        const o = {
          backgroundColor: '#E9EBF2',
          type: 'slider',
          show: !0,
          height: 12,
          dataBackground: {
            lineStyle: { color: '#DCDEE2' },
            areaStyle: { color: 'rgba(56, 107, 255, 0.1)' },
          },
          selectedDataBackground: {
            lineStyle: { color: '#C5C5C5' },
            areaStyle: { color: 'transparent' },
          },
          borderColor: '#fff',
          fillerColor: 'rgba(56, 107, 255, 0.1)',
          textStyle: { color: '#A1A3B4', fontSize: 10 },
          left: '29.16%',
          right: '29.16%',
          brushSelect: !1,
          start: 25,
          end: 75,
        }
        s(o, n),
          (e.dataZoom = o),
          d(t, 'grid.bottom') ||
            ((e.grid.bottom = 80), L(t) && h(t, 'legend.bottom', 48))
      }
      const f = s({}, t)
      if (
        (Reflect.deleteProperty(f, 'data'),
        Reflect.deleteProperty(f, 'xField'),
        Reflect.deleteProperty(f, 'yField'),
        s(e, f),
        l && l.name)
      ) {
        const t = F(l.name, i, 'right')
        S(e, o.RIGHT, t), (e.grid.right = e.grid.right + t)
      }
      if (c && c.name) {
        const t = F(c.name, i, 'left')
        S(e, o.LEFT, t)
      }
      if (i) {
        const o = E(t) ? 'xAxis' : 'yAxis'
        h(e, `${o}.axisLabel.formatter`, function(e) {
          return (100 * e).toFixed(p) + '%'
        }),
          d(e, `${o}.minInterval`) >= 1 && h(e, `${o}.minInterval`, 0.1)
      }
      if (A(t)) {
        d(t, 'xAxis.axisLabel.formatter') ||
          (h(e, 'xAxis.axisLabel.hideOverlap', !0),
          h(e, 'xAxis.axisLabel.formatter', e =>
            e.length >= 11
              ? (e => {
                  let t = 0,
                    o = 0,
                    r = 0
                  return (
                    e.split('').forEach((e, i) => {
                      ;(t = a(e) ? t + 1 : t + 0.5),
                        t >= 10 && 0 === o && (o = i),
                        t >= 20 && 0 === r && (r = i)
                    }),
                    t >= 10
                      ? r
                        ? `${e.slice(0, o)}\n${e.slice(o, r - 2)}...`
                        : `${e.slice(0, o)}\n${e.slice(o, e.length)}`
                      : e
                  )
                })(e)
              : e,
          ))
      }
    },
    b = e => {
      const t = d(e, 'xAxis.axisLabel.rotate'),
        o = v(e),
        r = ((e, t) => {
          let o = 0,
            r = 0
          return (
            e.split('').forEach(e => {
              a(e) ? o++ : r++
            }),
            Math.ceil(o * t + r * (t / 2))
          )
        })(w(o), u)
      return Math.sin(t) * (r >= 100 ? 100 : r)
    },
    A = e => {
      let t = !1
      return d(e, 'xAxis.axisLabel.rotate') && (t = !0), t
    },
    v = e => {
      const { xField: t, data: o, yField: r } = e
      let n = E(e) ? r : t
      return i(o) ? o[0].map(e => e[n]) : o.map(e => e[n])
    },
    E = e => 'category' === d(e, 'yAxis.type'),
    L = e => {
      let t = !0
      const o = d(e, 'name')
      return (
        (!1 !== d(e, 'legend.show') && o && o.length) || (t = !1),
        d(e, 'groupField') && (t = !0),
        t
      )
    },
    F = (e, t, o) => {
      const r = 'right' === o ? 10 : 8
      return e.length > 2 ? (e.length - 2) * (t ? r : 16) : 0
    },
    S = (e, t, o) => {
      e.grid[t] = e.grid[t] + o
    },
    w = e => {
      let t = ''
      return (
        e.forEach(e => {
          e.length > t.length && (t = e)
        }),
        t
      )
    }
  class O {
    constructor(e, t) {
      if (
        ((this.container =
          'string' == typeof e ? document.getElementById(e) : e),
        this._validate(e, t),
        this.container.setAttribute('chart-source', '17-chart'),
        this.container.offsetHeight <= 100 &&
          (this.container.style.height = '360px'),
        'category' === d(t, 'yAxis.type'))
      ) {
        const e = d(t, 'data')
        const o = 30 * (i(e) ? d(t, 'data.0').length : e.length)
        this.container.style.height = `${o}px`
      }
      if (A(t)) {
        const e = b(t)
        if (e > g && this.container.offsetHeight <= 360) {
          const t = e - g
          this.container.style.height = `${this.container.offsetHeight + t}px`
        }
      }
      const o = { renderer: t.renderer ? t.renderer : 'canvas' }
      ;(this.chart = r.init(this.container, void 0, o)),
        this._registerEvent(),
        new Promise(e => {
          e()
        }).then(() => {
          this.render()
        })
    }
    render() {
      this.chart.clear(), this.chart.setOption(this.option)
    }
    _resize() {
      this.chart.resize()
    }
    _registerEvent() {
      this._observeReisze()
    }
    _validate(e, t) {
      if (!e) throw TypeError('argument of container is required')
      if (!t) throw TypeError('argument of option is required')
      if ('string' != typeof e || this.container)
        if ('string' == typeof e || 1 === this.container.nodeType)
          if (((o = d(t, 'data')), Array.isArray(o))) var o
          else
            console.error('Invalid Type: options.data should be type of Array')
        else console.error('Invalid Type: container is not a dom element')
      else console.error(`Invalid id: Can't get the dom that id is ${e}`)
    }
    _observeReisze() {
      const e = new ResizeObserver(e => {
        this._resize()
      })
      this.container.parentElement && e.observe(this.container.parentElement)
    }
  }
  const _ = 'bar',
    T = 'line',
    R = 'scatter',
    C = 'pie',
    $ = (e, t) => {
      const { isPercent: o, percentFixed: r, name: i, isShowLabel: a } = t
      if (
        (o &&
          (h(e, 'tooltip.valueFormatter', function(e) {
            return (100 * e).toFixed(r) + '%'
          }),
          e.series.forEach(e => {
            h(e, 'label.formatter', function(e) {
              return (100 * e.value).toFixed(r) + '%'
            })
          })),
        i &&
          ('string' == typeof i
            ? h(e, 'series.0.name', i)
            : n(i) &&
              (i.forEach((t, o) => {
                h(e, `series.${o}.name`, t)
              }),
              h(e, 'tooltip.trigger', 'axis'))),
        L(t) && !t.dataZoom)
      ) {
        const t = d(e, 'grid.bottom')
        h(e, 'grid.bottom', t + 32)
      }
      ;(e => 'boolean' == typeof e)(a) &&
        e.series.map(e => {
          h(e, 'label.show', a)
        })
    },
    I = e => {
      const { data: t, xField: o, yField: r, isStack: a, labelColor: s } = e,
        l = E(e),
        c = (e, t) => {
          const i = {
            name: '',
            type: 'bar',
            barMaxWidth: 72,
            barMinWidth: 16,
            barGap: '30%',
            barCategoryGap: '50%',
            data: [],
            label: { show: !0, color: '#666', position: 'top' },
          }
          return (
            (i.data = e.map(e => e[l ? o : r])),
            a &&
              ((i.stack = 'total'),
              (i.label.position = 'inside'),
              s && void 0 !== t && (i.label.color = n(s) ? s[t] : s)),
            l && (i.label.position = 'right'),
            i
          )
        }
      return i(t) ? t.map((e, t) => c(e, t)) : [c(t)]
    }
  const D = e => {
    const { data: t, yField: o, smooth: r, areaStyle: n } = e,
      a = e => {
        const t = ((e, t) => {
          const o = {
            name: '',
            type: 'line',
            data: [],
            label: { show: !0, color: '#666', position: 'top' },
          }
          return e && (o.smooth = !0), t && (o.areaStyle = t), o
        })(r, n)
        return (t.data = e.map(e => e[o])), t
      }
    return i(t) ? t.map(e => a(e)) : [a(t)]
  }
  const H = e => {
    const { xField: t, yField: o, nameField: r, groupField: i, data: n } = e
    if (i) {
      return ((a = n.map(e => e[i])), Array.from(new Set(a))).map(e => {
        const a = {
          name: '',
          type: 'scatter',
          data: [],
          label: { show: !1, color: '#666', position: 'top' },
        }
        a.name = e
        const s = n
          .filter(t => t[i] === e)
          .map(e => ({ name: e[r], value: [e[t], e[o]] }))
        return (a.data = s), a
      })
    }
    {
      const e = {
          name: '',
          type: 'scatter',
          data: [],
          label: { show: !1, color: '#666', position: 'top' },
        },
        i = n.map(e => ({ name: e[r], value: [e[t], e[o]] }))
      return (e.data = i), [e]
    }
    var a
  }
  const P = e => {
    const { nameField: t, valueField: o } = e,
      { data: r } = e
    let i = r
    ;(t || o) &&
      (i = r.map(e => ({ name: t ? e[t] : e.name, value: o ? e[o] : e.name })))
    const n = (e => {
      const { radius: t } = e
      return { name: '', type: 'pie', radius: t || '50%', data: [] }
    })(e)
    return (n.data = i), [n]
  }
  return {
    Bar: class extends O {
      constructor(e, t) {
        super(e, t), (this.type = _)
        const o = {
          tooltip: {
            trigger: 'item',
            className: m,
            borderColor: '#fff',
            axisPointer: {
              type: 'shadow',
              shadowStyle: { color: '#F3F5F9', shadowBlur: 0.2, opacity: 0.04 },
            },
          },
          legend: {
            show: !0,
            bottom: 24,
            itemWidth: 8,
            itemHeight: 8,
            itemGap: 16,
            icon: 'rect',
          },
          color: y.THEME_PRIMARY_COLORS,
          grid: { top: 30, left: 0, right: 40, bottom: 24, containLabel: !0 },
          xAxis: {
            type: 'category',
            data: [],
            axisTick: { show: !1 },
            nameTextStyle: {
              color: '#999',
              verticalAlign: 'top',
              lineHeight: 22,
            },
            axisLabel: { rotate: 0, margin: 14, color: '#999' },
            axisLine: { lineStyle: { color: '#666', opacity: 0.9 } },
          },
          yAxis: {
            name: '',
            type: 'value',
            nameTextStyle: { align: 'right', color: '#999' },
            axisLabel: { color: '#999' },
            minInterval: 1,
            splitLine: { lineStyle: { color: '#D9D9D9' } },
          },
          series: [],
        }
        ;((e, t) => {
          E(t) ? (e.yAxis.data = v(t)) : (e.xAxis.data = v(t)),
            (e.series = I(t))
        })(o, t),
          x(o, t),
          $(o, t),
          (this.option = o)
      }
    },
    Line: class extends O {
      constructor(e, t) {
        super(e, t), (this.type = T)
        const o = {
          tooltip: { trigger: 'axis', borderColor: '#fff' },
          legend: {
            show: !0,
            bottom: 24,
            itemWidth: 8,
            itemHeight: 8,
            itemGap: 16,
            icon: 'circle',
          },
          color: y.THEME_PRIMARY_COLORS,
          grid: { top: 30, left: 0, right: 40, bottom: 24, containLabel: !0 },
          xAxis: {
            type: 'category',
            data: [],
            axisTick: { show: !1 },
            nameTextStyle: {
              color: '#999',
              verticalAlign: 'top',
              lineHeight: 22,
            },
            axisLabel: { rotate: 0, margin: 14, color: '#999' },
            axisLine: { lineStyle: { color: '#666', opacity: 0.9 } },
          },
          yAxis: {
            name: '',
            type: 'value',
            nameTextStyle: { align: 'right', color: '#999' },
            axisLabel: { color: '#999' },
            minInterval: 1,
            splitLine: { lineStyle: { color: '#D9D9D9' } },
          },
          series: [],
        }
        ;((e, t) => {
          E(t) &&
            console.warn(
              'Invalid Option:Chart Line not allowed to set YAxis as category axis',
            ),
            (e.xAxis.data = v(t)),
            (e.series = D(t))
        })(o, t),
          x(o, t),
          $(o, t),
          (this.option = o)
      }
    },
    Scatter: class extends O {
      constructor(e, t) {
        super(e, t), (this.type = R)
        const o = {
          tooltip: {
            trigger: 'item',
            formatter: e => {
              const { marker: t, name: o, value: r, dimensionNames: i } = e
              return `${o}${o ? '<br>' : ''}\n        ${t}${i[0]}:${
                r[0]
              },\n        ${i[1]}:${r[1]}`
            },
            borderColor: '#fff',
          },
          legend: {
            show: !0,
            bottom: 24,
            itemWidth: 8,
            itemHeight: 8,
            itemGap: 16,
            icon: 'circle',
          },
          color: y.THEME_PRIMARY_COLORS,
          grid: { top: 30, left: 0, right: 40, bottom: 24, containLabel: !0 },
          xAxis: {
            axisTick: { show: !1 },
            nameTextStyle: {
              color: '#999',
              verticalAlign: 'top',
              lineHeight: 22,
            },
            axisLabel: { rotate: 0, margin: 14, color: '#999' },
            axisLine: { lineStyle: { color: '#666', opacity: 0.9 } },
          },
          yAxis: {
            name: '',
            nameTextStyle: { align: 'right', color: '#999' },
            axisLabel: { color: '#999' },
            minInterval: 1,
            splitLine: { lineStyle: { color: '#D9D9D9' } },
          },
          series: [],
        }
        ;((e, t) => {
          E(t) &&
            console.warn(
              'Invalid Option:Chart Line not allowed to set YAxis as category axis',
            ),
            (e.series = H(t))
        })(o, t),
          x(o, t),
          $(o, t),
          (this.option = o)
      }
    },
    Pie: class extends O {
      constructor(e, t) {
        super(e, t), (this.type = C)
        const o = {
          color: y.THEME_PRIMARY_COLORS,
          tooltip: { trigger: 'item', borderColor: '#fff' },
          legend: { bottom: 16 },
          series: [],
        }
        ;((e, t) => {
          e.series = P(t)
        })(o, t),
          $(o, t),
          (this.option = o)
      }
    },
  }
})
